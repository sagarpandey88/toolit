{"version":3,"file":"index.js","mappings":"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","sources":["webpack://toolit-ts-common/./src/Utilities/clientSideEvents.ts","webpack://toolit-ts-common/./src/Utilities/clientSideStorage.ts","webpack://toolit-ts-common/./src/Utilities/clientSideElementObserver.ts"],"sourcesContent":["/* eslint-disable */\n//Global declaration of the event list to avoid duplicate entries of the event.\nconst myDocsRegistryName = 'ClientEventRegistry';\nif (!globalThis[myDocsRegistryName]) {\n    globalThis[myDocsRegistryName] = [];\n}\n\n/**\n* Event Interface\n*/\nexport interface IClientSideEvent {\n    name: string;\n    eventHandler: (...params: unknown[]) => void;\n    dispatchEvent?: (...params: unknown[]) => void;\n    type?: string;\n    id?: number;\n    sequence?: number;\n}\n\n\n/**\n * Enables accessing cross component events to decouple components.\n * Provides AttachEvent and Dispatch Event methods for event processing.\n */\nexport class MDClientEventHandler {\n    public get EventHandlerList(): IClientSideEvent[] {\n        return globalThis[myDocsRegistryName];\n    }\n\n    /**\n     * Attaches event and bind event handler\n     * @param eventName Name of the event , this will be used to call the event.\n     * @param eventHandler Method to handle the event. The method is passed data.detail of the event for data transfer across from caller to component where the event is bound.\n     * @returns Index of the attached Event in the global event list.\n     */\n    public AttachEvent(\n        eventName: string,\n        eventHandler: (...params: unknown[]) => void,\n        dispatchEvent?: (...params: unknown[]) => void\n    ): number {\n        let eventIndex = -1;\n        const event: IClientSideEvent = {\n            name: eventName,\n            eventHandler: eventHandler,\n            dispatchEvent: dispatchEvent,\n        };\n\n        if (\n            globalThis[myDocsRegistryName].filter((x) => x.name == eventName)\n                .length == 0\n        ) {\n            //attach the event\n            document.addEventListener(eventName, (data: CustomEventInit) => {\n                eventHandler(...this.ObjectValuesAsArray(data.detail));\n            });\n            //assign the index\n            eventIndex = globalThis[myDocsRegistryName].push(event) - 1;\n        }\n        return eventIndex;\n    }\n\n\n\n\n    /**\n     * Dispatches the event bounded by another component.\n     * @param eventName Name of the event attached to the target component.\n     * @param data Data to be passed to event handler.\n     */\n    //public DispatchEvent(eventName: string, data?: {}) {\n    public DispatchEvent(eventName: string, ...params: unknown[]) {\n        //const param: {} = data ? data : {};\n\n        document.dispatchEvent(\n            new CustomEvent(eventName, {\n                detail: { ...params },\n            })\n        );\n    }\n\n\n    private ObjectValuesAsArray(object: Object) {\n        const arr: any[] = [];\n        for (const item in object) {\n            arr.push(object[item]);\n        }\n        return arr;\n    }\n}\n\n","/**\n * Class to handle client side key value based storage.\n *  Storage Options: Local Storage (Browser Persistent) ,  Session Storage (Session Persistent) via constructor.\n *\n */\n export class MDClientStorage implements IClientStorage {\n    private _storageType: StorageType;\n  \n    private _clientStorage: IClientStorage | Storage;\n  \n    /**\n     * Default Constructor of Client Storage which sets the value of Storage provider based on storage type specified.\n     * storageType: option to choose between Local , Session and Index Db\n     * preCache: this is available only in case of IndexDb. setting true loads the result set in a local variable for faster load times. Not recommended if the data set is large. default is false\n     */\n    constructor(storageType: StorageType, preCache?: boolean) {\n      this._storageType = storageType;\n  \n      switch (storageType) {\n        case StorageType.LocalStorage:\n          this._clientStorage = window.localStorage;\n          break;\n        case StorageType.SessionStorage:\n          this._clientStorage = window.sessionStorage;\n          break;\n        case StorageType.IndexedDb:\n          this._clientStorage = new IndexedDbStorage(undefined, preCache);\n          break;\n      }\n    }\n  \n    /**\n     * Gets the value from client storage. If expiration time was provided while setting will check and remove the item from session if date is passed.\n     * @param key Key of the value to fetch\n     */\n    public async getItem(key: string): Promise<string> {\n      const stringValue = await this._clientStorage.getItem(key);\n      if (stringValue !== null) {\n        const value = JSON.parse(stringValue);\n  \n        //if the value has expiration date then return only if the expiration date has not passed.\n        if (value.expirationDate) {\n          const expirationDate = new Date(value.expirationDate);\n          if (expirationDate > new Date()) {\n            return JSON.stringify(value.value);\n          } else {\n            this._clientStorage.removeItem(key);\n          }\n        } else {\n          return JSON.stringify(value);\n        }\n      }\n      return null;\n    }\n  \n    /**\n     *\n     * @param key key of the value to be storage\n     * @param value value to be stored\n     * @param timeToExpireInMins (Optional) time to expire the value in minutes.\n     */\n    public setItem(\n      key: string,\n      value: unknown,\n      timeToExpireInMins?: number\n    ): void {\n      try {\n        //if expiration is provided then add the expiration in the value\n        if (timeToExpireInMins) {\n          const expirationDate = new Date(\n            new Date().getTime() + 60000 * timeToExpireInMins\n          );\n          const newValue = {\n            value: value,\n            expirationDate: expirationDate.toISOString(),\n          };\n          this._clientStorage.setItem(key, JSON.stringify(newValue));\n        } else {\n          this._clientStorage.setItem(key, JSON.stringify(value)); //set the value as it is if no expiration time is mentioned\n        }\n      } catch (error) {}\n    }\n  \n    /**\n     * Clears the storage and empties all the values in the storage.\n     */\n    public clear(): void {\n      this._clientStorage.clear();\n    }\n  \n    /**\n     * Removes the key from storage\n     * @param key key of the value to be removed\n     */\n    public removeItem(key: string): void {\n      this._clientStorage.removeItem(key);\n    }\n  }\n  \n  export enum StorageType {\n    LocalStorage,\n    SessionStorage,\n    IndexedDb,\n  }\n  \n  interface IClientStorage {\n    getItem(key: string): Promise<string>;\n    setItem(key: string, value: unknown, timeToExpireInMins?: number): void;\n    clear(): void;\n    removeItem(key: string): void;\n  }\n  \n  class IndexedDbStorage implements IClientStorage {\n    [name: string]: unknown;\n    length: number=0;\n    static _instance: IndexedDbStorage;\n    private _indexedDb: IDBDatabase= null;\n    private _CacheDb = 'CacheIndexDb'; //constant\n    private readonly _CacheStore: string = 'CacheStore'; //constant\n    private _CachedObjects: IIDbStorageObject[]; //property\n    private _isCacheStoreLoaded = false; //property\n    private _isPreCache = false;\n  \n    /**\n     * Returns an instance of IndexedDbStorage , it has a singleton instance.\n     * dbName: name of the Db to connect else default _CacheDb value will be selected.\n     * preCache: preloads the result in an object.Not recommended if the data set in Indexed Db is large\n     */\n    constructor(dbName?: string, preCache?: boolean) {\n      if (IndexedDbStorage._instance) {\n        return IndexedDbStorage._instance;\n      }\n  \n      this._CachedObjects = [];\n      if (preCache) this._isPreCache = preCache;\n  \n      this.initialize(dbName);\n  \n      IndexedDbStorage._instance = this;\n    }\n  \n    public clear(): void {\n      const request = this.getCacheStore().clear();\n      request.onsuccess = () => {\n        // can use event if needed(event)\n        this._CachedObjects = [];\n      };\n    }\n    public async getItem(key: string): Promise<string> {\n      //return the data from precache\n      if (this._isPreCache) {\n        if (!this._isCacheStoreLoaded) {\n          await this.initialize(this._CacheDb);\n        }\n        const selectedItems = this._CachedObjects.filter((x) => x.name === key);\n        return selectedItems.length > 0\n          ? (selectedItems[0].value as string)\n          : null;\n      }\n  \n      //else return the data by getting the value from indexedDb\n      return new Promise((resolve, reject) => {\n        const objectRequest = this.getCacheStore().get(key);\n        objectRequest.onsuccess = () => {\n          if (objectRequest.result) resolve(objectRequest.result.value);\n          else reject(Error('object not found'));\n        };\n      });\n    }\n  \n    public key(index: number): string {\n      return this._CachedObjects[index].value as string;\n    }\n    public removeItem(key: string, callback?: () => void): void {\n      const request = this.getCacheStore().delete(key);\n      request.onsuccess = () => {\n        this._CachedObjects = this._CachedObjects.filter(\n          (x) => x.name != key\n        );\n  \n        if (callback) {\n          callback();\n        }\n      };\n    }\n    public setItem(key: string, value: string): void {\n      const request = this.getCacheStore().put({ name: key, value: value });\n  \n      request.onsuccess = () => {\n        // can use event if needed(event)\n        this.loadStorageCache();\n      };\n    }\n  \n    private initialize(dbName: string): Promise<boolean> {\n      if (!dbName) {\n        dbName = this._CacheDb;\n      } else {\n        this._CacheDb = dbName;\n      }\n  \n      return new Promise((resolve, reject) => {\n        const dbConnectionRequest = window.indexedDB.open(dbName, 1);\n        dbConnectionRequest.onsuccess = () => {\n          // can use event if needed(event: Event)\n          this._indexedDb = dbConnectionRequest.result;\n          this.loadStorageCache(resolve);\n        };\n  \n        dbConnectionRequest.onerror = function () {\n          // can use event if needed(event: Event)\n          // Generic error handler for all errors targeted at this database's\n          // requests!\n          reject(false);\n        };\n  \n        dbConnectionRequest.onupgradeneeded = () => {\n          // can use event if needed(event: IDBVersionChangeEvent)\n          // Save the IDBDatabase interface\n          const db = dbConnectionRequest.result; //current connect request\n  \n          // Create an objectStore for this database\n          //const objectStore =\n          db.createObjectStore(this._CacheStore, {\n            keyPath: 'name',\n          });\n        };\n      });\n    }\n  \n    private loadStorageCache(callback?: (isSuccess: boolean) => void) {\n      if (this._isPreCache) {\n        const request = this.getCacheStore().getAll();\n  \n        request.onsuccess = () => {\n          // can use event if needed(event: Event)\n          this._CachedObjects = request.result;\n          this._isCacheStoreLoaded = true;\n          if (callback) callback(true);\n        };\n      }\n    }\n  \n    private getCacheStore(): IDBObjectStore {\n      return this._indexedDb\n        .transaction([this._CacheStore], 'readwrite')\n        .objectStore(this._CacheStore);\n    }\n  }\n  \n  interface IIDbStorageObject {\n    [name: string]: unknown;\n    value: unknown;\n  }\n  ","const cseObservableList = 'ClientSideElementObservableList';\nif (!globalThis[cseObservableList]) {\n    globalThis[cseObservableList] = [];\n}\n\nexport class ClientSideElementObserver {\n\n    private observableList = () => { return globalThis[cseObservableList]; };\n\n    /**\n     * Observes element for changes and invokes callback if change is observed.\n     * @param observationId Unique observation id\n     * @param element HTML element to be observed\n     * @param callback callback function which will have mutated objects as first parameter, observer as the second.\n     * @returns Observer object\n     */\n    public observeElement = (observationId: string, element: HTMLElement, callback: MutationCallback) => {\n\n        if (\n            this.observableList().length > 0 &&\n            this.observableList().filter((x) => x.id == observationId)\n                .length == 0\n        ) {\n            return null;\n        }\n        let observer = new MutationObserver(callback);\n\n        // observe everything except attributes\n        observer.observe(element, {\n            childList: true, // observe direct children\n            subtree: true, // and lower descendants too\n            characterDataOldValue: true, // pass old data to callback\n        });\n\n        this.observableList().push({ id: observationId, observer });\n\n        return observer;\n\n    }\n\n    /**\n     * Observes element for changes and invokes callback if change is observed.\n     * @param observationId  Unique observation id\n     * @param elemId Id of the element to be observed\n     * @param callback callback function which will have mutated objects as first parameter, observer as the second.\n     */\n    public observeElementById = (observationId, elemId, callback) => {\n        const elem = document.getElementById(elemId);\n        this.observeElement(observationId, elem, callback);\n    };\n\n/**\n * Stops observing the element\n * @param obvId Unique id of the observation\n */\n    public stopObserving = (obvId) => {\n        this.observableList()\n            .filter((x) => (x.id = obvId))[0]\n            .disconnect();\n    };\n\n}\n\n"],"names":["globalThis","AttachEvent","eventName","eventHandler","dispatchEvent","eventIndex","event","name","filter","x","length","document","addEventListener","data","ObjectValuesAsArray","detail","push","DispatchEvent","CustomEvent","params","object","arr","item","StorageType","storageType","preCache","this","_storageType","LocalStorage","_clientStorage","window","localStorage","SessionStorage","sessionStorage","IndexedDb","IndexedDbStorage","undefined","getItem","key","stringValue","value","JSON","parse","expirationDate","stringify","Date","removeItem","setItem","timeToExpireInMins","newValue","getTime","toISOString","error","clear","dbName","_indexedDb","_CacheDb","_CacheStore","_isCacheStoreLoaded","_isPreCache","_instance","_CachedObjects","initialize","getCacheStore","onsuccess","selectedItems","Promise","resolve","reject","objectRequest","get","result","Error","index","callback","delete","put","loadStorageCache","dbConnectionRequest","indexedDB","open","onerror","onupgradeneeded","createObjectStore","keyPath","getAll","transaction","objectStore","cseObservableList"],"sourceRoot":""}